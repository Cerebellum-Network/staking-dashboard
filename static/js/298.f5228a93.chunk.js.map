{"version":3,"file":"static/js/298.f5228a93.chunk.js","mappings":"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","sources":["../node_modules/@substrate/smoldot-light/dist/mjs/instance/buffer.js","../node_modules/@substrate/smoldot-light/dist/mjs/tiny-inflate/index.js","../node_modules/@substrate/smoldot-light/dist/mjs/instance/bindings-smoldot-light.js","../node_modules/@substrate/smoldot-light/dist/mjs/instance/bindings-wasi.js","../node_modules/@substrate/smoldot-light/dist/mjs/instance/raw-instance.js","../node_modules/@substrate/smoldot-light/dist/mjs/instance/autogen/wasm.js","../node_modules/@substrate/smoldot-light/dist/mjs/client.js","../node_modules/@substrate/smoldot-light/dist/mjs/instance/instance.js","../node_modules/@substrate/smoldot-light/dist/mjs/index-browser.js"],"sourcesContent":["// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nexport function utf8BytesToString(buffer, offset, length) {\n    checkRange(buffer, offset, length);\n    // The `TextDecoder` API is supported by all major browsers and by NodeJS.\n    // <https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder>\n    return new TextDecoder().decode(buffer.slice(offset, offset + length));\n}\nexport function readUInt32LE(buffer, offset) {\n    checkRange(buffer, offset, 4);\n    return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16)) + (buffer[offset + 3] * 0x1000000);\n}\n/**\n * Sets the value of a given byte in the buffer.\n *\n * This function is equivalent to `buffer[offset] = value`, except that an exception is thrown\n * if `offset` is out of range.\n */\nexport function writeUInt8(buffer, offset, value) {\n    checkRange(buffer, offset, 1);\n    buffer[offset] = value & 0xff;\n}\nexport function writeUInt32LE(buffer, offset, value) {\n    checkRange(buffer, offset, 4);\n    buffer[offset + 3] = (value >>> 24) & 0xff;\n    buffer[offset + 2] = (value >>> 16) & 0xff;\n    buffer[offset + 1] = (value >>> 8) & 0xff;\n    buffer[offset] = value & 0xff;\n}\nfunction checkRange(buffer, offset, length) {\n    if (!Number.isInteger(offset) || offset < 0)\n        throw new RangeError();\n    if (offset + length > buffer.length)\n        throw new RangeError();\n}\n/**\n * Decodes a base64 string.\n *\n * The input is assumed to be correct.\n */\nexport function trustedBase64Decode(base64) {\n    // This implementation was mostly copy-pasted (with some adjustments)\n    // from <https://developer.mozilla.org/en-US/docs/Glossary/Base64>. As indicated in the\n    // about section (<https://developer.mozilla.org/en-US/docs/MDN/About>), this code is in the\n    // public domain.\n    function b64ToUint6(nChr) {\n        return nChr > 64 && nChr < 91 ?\n            nChr - 65\n            : nChr > 96 && nChr < 123 ?\n                nChr - 71\n                : nChr > 47 && nChr < 58 ?\n                    nChr + 4\n                    : nChr === 43 ?\n                        62\n                        : nChr === 47 ?\n                            63\n                            :\n                                0;\n    }\n    const nInLen = base64.length;\n    const nOutLen = nInLen * 3 + 1 >> 2;\n    const taBytes = new Uint8Array(nOutLen);\n    for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n        nMod4 = nInIdx & 3;\n        nUint24 |= b64ToUint6(base64.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n        if (nMod4 === 3 || nInLen - nInIdx === 1) {\n            for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n                taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n            }\n            nUint24 = 0;\n        }\n    }\n    return taBytes;\n}\n","var TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\nfunction Tree() {\n    this.table = new Uint16Array(16); /* table of code length counts */\n    this.trans = new Uint16Array(288); /* code -> symbol translation table */\n}\nfunction Data(source, dest) {\n    this.source = source;\n    this.sourceIndex = 0;\n    this.tag = 0;\n    this.bitcount = 0;\n    this.dest = dest;\n    this.destLen = 0;\n    this.ltree = new Tree(); /* dynamic length/symbol tree */\n    this.dtree = new Tree(); /* dynamic distance tree */\n}\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\nvar sltree = new Tree();\nvar sdtree = new Tree();\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n    16, 17, 18, 0, 8, 7, 9, 6,\n    10, 5, 11, 4, 12, 3, 13, 2,\n    14, 1, 15\n]);\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n    var i, sum;\n    /* build bits table */\n    for (i = 0; i < delta; ++i)\n        bits[i] = 0;\n    for (i = 0; i < 30 - delta; ++i)\n        bits[i + delta] = i / delta | 0;\n    /* build base table */\n    for (sum = first, i = 0; i < 30; ++i) {\n        base[i] = sum;\n        sum += 1 << bits[i];\n    }\n}\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n    var i;\n    /* build fixed length tree */\n    for (i = 0; i < 7; ++i)\n        lt.table[i] = 0;\n    lt.table[7] = 24;\n    lt.table[8] = 152;\n    lt.table[9] = 112;\n    for (i = 0; i < 24; ++i)\n        lt.trans[i] = 256 + i;\n    for (i = 0; i < 144; ++i)\n        lt.trans[24 + i] = i;\n    for (i = 0; i < 8; ++i)\n        lt.trans[24 + 144 + i] = 280 + i;\n    for (i = 0; i < 112; ++i)\n        lt.trans[24 + 144 + 8 + i] = 144 + i;\n    /* build fixed distance tree */\n    for (i = 0; i < 5; ++i)\n        dt.table[i] = 0;\n    dt.table[5] = 32;\n    for (i = 0; i < 32; ++i)\n        dt.trans[i] = i;\n}\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\nfunction tinf_build_tree(t, lengths, off, num) {\n    var i, sum;\n    /* clear code length count table */\n    for (i = 0; i < 16; ++i)\n        t.table[i] = 0;\n    /* scan symbol lengths, and sum code length counts */\n    for (i = 0; i < num; ++i)\n        t.table[lengths[off + i]]++;\n    t.table[0] = 0;\n    /* compute offset table for distribution sort */\n    for (sum = 0, i = 0; i < 16; ++i) {\n        offs[i] = sum;\n        sum += t.table[i];\n    }\n    /* create code->symbol translation table (symbols sorted by code) */\n    for (i = 0; i < num; ++i) {\n        if (lengths[off + i])\n            t.trans[offs[lengths[off + i]]++] = i;\n    }\n}\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n    /* check if tag is empty */\n    if (!d.bitcount--) {\n        /* load next tag */\n        d.tag = d.source[d.sourceIndex++];\n        d.bitcount = 7;\n    }\n    /* shift bit out of tag */\n    var bit = d.tag & 1;\n    d.tag >>>= 1;\n    return bit;\n}\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n    if (!num)\n        return base;\n    while (d.bitcount < 24) {\n        d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n        d.bitcount += 8;\n    }\n    var val = d.tag & (0xffff >>> (16 - num));\n    d.tag >>>= num;\n    d.bitcount -= num;\n    return val + base;\n}\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n    while (d.bitcount < 24) {\n        d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n        d.bitcount += 8;\n    }\n    var sum = 0, cur = 0, len = 0;\n    var tag = d.tag;\n    /* get more bits while code value is above sum */\n    do {\n        cur = 2 * cur + (tag & 1);\n        tag >>>= 1;\n        ++len;\n        sum += t.table[len];\n        cur -= t.table[len];\n    } while (cur >= 0);\n    d.tag = tag;\n    d.bitcount -= len;\n    return t.trans[sum + cur];\n}\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n    var hlit, hdist, hclen;\n    var i, num, length;\n    /* get 5 bits HLIT (257-286) */\n    hlit = tinf_read_bits(d, 5, 257);\n    /* get 5 bits HDIST (1-32) */\n    hdist = tinf_read_bits(d, 5, 1);\n    /* get 4 bits HCLEN (4-19) */\n    hclen = tinf_read_bits(d, 4, 4);\n    for (i = 0; i < 19; ++i)\n        lengths[i] = 0;\n    /* read code lengths for code length alphabet */\n    for (i = 0; i < hclen; ++i) {\n        /* get 3 bits code length (0-7) */\n        var clen = tinf_read_bits(d, 3, 0);\n        lengths[clcidx[i]] = clen;\n    }\n    /* build code length tree */\n    tinf_build_tree(code_tree, lengths, 0, 19);\n    /* decode code lengths for the dynamic trees */\n    for (num = 0; num < hlit + hdist;) {\n        var sym = tinf_decode_symbol(d, code_tree);\n        switch (sym) {\n            case 16:\n                /* copy previous code length 3-6 times (read 2 bits) */\n                var prev = lengths[num - 1];\n                for (length = tinf_read_bits(d, 2, 3); length; --length) {\n                    lengths[num++] = prev;\n                }\n                break;\n            case 17:\n                /* repeat code length 0 for 3-10 times (read 3 bits) */\n                for (length = tinf_read_bits(d, 3, 3); length; --length) {\n                    lengths[num++] = 0;\n                }\n                break;\n            case 18:\n                /* repeat code length 0 for 11-138 times (read 7 bits) */\n                for (length = tinf_read_bits(d, 7, 11); length; --length) {\n                    lengths[num++] = 0;\n                }\n                break;\n            default:\n                /* values 0-15 represent the actual code lengths */\n                lengths[num++] = sym;\n                break;\n        }\n    }\n    /* build dynamic trees */\n    tinf_build_tree(lt, lengths, 0, hlit);\n    tinf_build_tree(dt, lengths, hlit, hdist);\n}\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n    while (1) {\n        var sym = tinf_decode_symbol(d, lt);\n        /* check for end of block */\n        if (sym === 256) {\n            return TINF_OK;\n        }\n        if (sym < 256) {\n            d.dest[d.destLen++] = sym;\n        }\n        else {\n            var length, dist, offs;\n            var i;\n            sym -= 257;\n            /* possibly get more bits from length code */\n            length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n            dist = tinf_decode_symbol(d, dt);\n            /* possibly get more bits from distance code */\n            offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n            /* copy match */\n            for (i = offs; i < offs + length; ++i) {\n                d.dest[d.destLen++] = d.dest[i];\n            }\n        }\n    }\n}\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n    var length, invlength;\n    var i;\n    /* unread from bitbuffer */\n    while (d.bitcount > 8) {\n        d.sourceIndex--;\n        d.bitcount -= 8;\n    }\n    /* get length */\n    length = d.source[d.sourceIndex + 1];\n    length = 256 * length + d.source[d.sourceIndex];\n    /* get one's complement of length */\n    invlength = d.source[d.sourceIndex + 3];\n    invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n    /* check length */\n    if (length !== (~invlength & 0x0000ffff))\n        return TINF_DATA_ERROR;\n    d.sourceIndex += 4;\n    /* copy block */\n    for (i = length; i; --i)\n        d.dest[d.destLen++] = d.source[d.sourceIndex++];\n    /* make sure we start next block on a byte boundary */\n    d.bitcount = 0;\n    return TINF_OK;\n}\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n    var d = new Data(source, dest);\n    var bfinal, btype, res;\n    do {\n        /* read final block flag */\n        bfinal = tinf_getbit(d);\n        /* read block type (2 bits) */\n        btype = tinf_read_bits(d, 2, 0);\n        /* decompress block */\n        switch (btype) {\n            case 0:\n                /* decompress uncompressed block */\n                res = tinf_inflate_uncompressed_block(d);\n                break;\n            case 1:\n                /* decompress block with fixed huffman trees */\n                res = tinf_inflate_block_data(d, sltree, sdtree);\n                break;\n            case 2:\n                /* decompress block with dynamic huffman trees */\n                tinf_decode_trees(d, d.ltree, d.dtree);\n                res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n                break;\n            default:\n                res = TINF_DATA_ERROR;\n        }\n        if (res !== TINF_OK)\n            throw new Error('Data error');\n    } while (!bfinal);\n    if (d.destLen < d.dest.length) {\n        if (typeof d.dest.slice === 'function')\n            return d.dest.slice(0, d.destLen);\n        else\n            return d.dest.subarray(0, d.destLen);\n    }\n    return d.dest;\n}\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\nexport default tinf_uncompress;\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n//! Exports a function that provides bindings for the bindings found in the Rust part of the code.\n//!\n//! In order to use this code, call the function passing an object, then fill the `instance` field\n//! of that object with the Wasm instance.\nimport * as buffer from './buffer.js';\n/**\n * Emitted by `connect` if the multiaddress couldn't be parsed or contains an invalid protocol.\n *\n * @see connect\n */\nexport class ConnectionError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexport default function (config) {\n    // Used below to store the list of all connections.\n    // The indices within this array are chosen by the Rust code.\n    let connections = {};\n    // Object containing a boolean indicating whether the `killAll` function has been invoked by\n    // the user.\n    const killedTracked = { killed: false };\n    const killAll = () => {\n        killedTracked.killed = true;\n        // TODO: kill timers as well?\n        for (const connection in connections) {\n            connections[connection].close();\n            delete connections[connection];\n        }\n    };\n    const imports = {\n        // Must exit with an error. A human-readable message can be found in the WebAssembly\n        // memory in the given buffer.\n        panic: (ptr, len) => {\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            const message = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);\n            config.onPanic(message);\n        },\n        // Used by the Rust side to emit a JSON-RPC response or subscription notification.\n        json_rpc_respond: (ptr, len, chainId) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            let message = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);\n            if (config.jsonRpcCallback) {\n                config.jsonRpcCallback(message, chainId);\n            }\n        },\n        // Used by the Rust side in response to asking for the database content of a chain.\n        database_content_ready: (ptr, len, chainId) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            let content = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);\n            if (config.databaseContentCallback) {\n                config.databaseContentCallback(content, chainId);\n            }\n        },\n        // Used by the Rust side to emit a log entry.\n        // See also the `max_log_level` parameter in the configuration.\n        log: (level, targetPtr, targetLen, messagePtr, messageLen) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            targetPtr >>>= 0;\n            targetLen >>>= 0;\n            messagePtr >>>= 0;\n            messageLen >>>= 0;\n            if (config.logCallback) {\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                let target = buffer.utf8BytesToString(mem, targetPtr, targetLen);\n                let message = buffer.utf8BytesToString(mem, messagePtr, messageLen);\n                config.logCallback(level, target, message);\n            }\n        },\n        // Must return the UNIX time in milliseconds.\n        unix_time_ms: () => Date.now(),\n        // Must return the value of a monotonic clock in milliseconds.\n        monotonic_clock_ms: () => config.performanceNow(),\n        // Must call `timer_finished` after the given number of milliseconds has elapsed.\n        start_timer: (id, ms) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            // In both NodeJS and browsers, if `setTimeout` is called with a value larger than\n            // 2147483647, the delay is for some reason instead set to 1.\n            // As mentioned in the documentation of `start_timer`, it is acceptable to end the\n            // timer before the given number of milliseconds has passed.\n            if (ms > 2147483647)\n                ms = 2147483647;\n            // In browsers, `setTimeout` works as expected when `ms` equals 0. However, NodeJS\n            // requires a minimum of 1 millisecond (if `0` is passed, it is automatically replaced\n            // with `1`) and wants you to use `setImmediate` instead.\n            if (ms == 0 && typeof setImmediate === \"function\") {\n                setImmediate(() => {\n                    if (killedTracked.killed)\n                        return;\n                    try {\n                        instance.exports.timer_finished(id);\n                    }\n                    catch (_error) { }\n                });\n            }\n            else {\n                setTimeout(() => {\n                    if (killedTracked.killed)\n                        return;\n                    try {\n                        instance.exports.timer_finished(id);\n                    }\n                    catch (_error) { }\n                }, ms);\n            }\n        },\n        // Must create a new connection object. This implementation stores the created object in\n        // `connections`.\n        connection_new: (connectionId, addrPtr, addrLen, errorPtrPtr) => {\n            const instance = config.instance;\n            addrPtr >>>= 0;\n            addrLen >>>= 0;\n            errorPtrPtr >>>= 0;\n            if (!!connections[connectionId]) {\n                throw new Error(\"internal error: connection already allocated\");\n            }\n            try {\n                if (killedTracked.killed)\n                    throw new Error(\"killAll invoked\");\n                const address = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), addrPtr, addrLen);\n                const connec = config.connect({\n                    address,\n                    onOpen: () => {\n                        if (killedTracked.killed)\n                            return;\n                        try {\n                            instance.exports.connection_open_single_stream(connectionId);\n                        }\n                        catch (_error) { }\n                    },\n                    onClose: (message) => {\n                        if (killedTracked.killed)\n                            return;\n                        try {\n                            const encoded = new TextEncoder().encode(message);\n                            const ptr = instance.exports.alloc(encoded.length) >>> 0;\n                            new Uint8Array(instance.exports.memory.buffer).set(encoded, ptr);\n                            instance.exports.connection_closed(connectionId, ptr, encoded.length);\n                        }\n                        catch (_error) { }\n                    },\n                    onMessage: (message) => {\n                        if (killedTracked.killed)\n                            return;\n                        try {\n                            const ptr = instance.exports.alloc(message.length) >>> 0;\n                            new Uint8Array(instance.exports.memory.buffer).set(message, ptr);\n                            instance.exports.stream_message(connectionId, 0, ptr, message.length);\n                        }\n                        catch (_error) { }\n                    }\n                });\n                connections[connectionId] = connec;\n                return 0;\n            }\n            catch (error) {\n                const isBadAddress = error instanceof ConnectionError;\n                let errorStr = \"Unknown error\";\n                if (error instanceof Error) {\n                    errorStr = error.toString();\n                }\n                const mem = new Uint8Array(instance.exports.memory.buffer);\n                const encoded = new TextEncoder().encode(errorStr);\n                const ptr = instance.exports.alloc(encoded.length) >>> 0;\n                mem.set(encoded, ptr);\n                buffer.writeUInt32LE(mem, errorPtrPtr, ptr);\n                buffer.writeUInt32LE(mem, errorPtrPtr + 4, encoded.length);\n                buffer.writeUInt8(mem, errorPtrPtr + 8, isBadAddress ? 1 : 0);\n                return 1;\n            }\n        },\n        // Must close and destroy the connection object.\n        connection_close: (connectionId) => {\n            if (killedTracked.killed)\n                return;\n            const connection = connections[connectionId];\n            connection.close();\n            delete connections[connectionId];\n        },\n        // Opens a new substream on a multi-stream connection\n        connection_stream_open: (_connectionId) => {\n            // Given that multi-stream connections are never opened at the moment, this function\n            // should never be called.\n        },\n        // Closes a substream on a multi-stream connection\n        connection_stream_close: (_connectionId, _streamId) => {\n            // Given that multi-stream connections are never opened at the moment, this function\n            // should never be called.\n        },\n        // Must queue the data found in the WebAssembly memory at the given pointer. It is assumed\n        // that this function is called only when the connection is in an open state.\n        stream_send: (connectionId, _streamId, ptr, len) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            const data = new Uint8Array(instance.exports.memory.buffer).slice(ptr, ptr + len);\n            const connection = connections[connectionId];\n            connection.send(data);\n        },\n        current_task_entered: (ptr, len) => {\n            if (killedTracked.killed)\n                return;\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            const taskName = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);\n            if (config.currentTaskCallback)\n                config.currentTaskCallback(taskName);\n        },\n        current_task_exit: () => {\n            if (killedTracked.killed)\n                return;\n            if (config.currentTaskCallback)\n                config.currentTaskCallback(null);\n        }\n    };\n    return { imports, killAll };\n}\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n//! Exports a function that provides bindings for the Wasi interface.\n//!\n//! These bindings can then be used by the Wasm virtual machine to invoke Wasi-related functions.\n//! See <https://wasi.dev/>.\n//!\n//! In order to use this code, call the function passing an object, then fill the `instance` field\n//! of that object with the Wasm instance.\nimport * as buffer from './buffer.js';\nexport default (config) => {\n    // Buffers holding temporary data being written by the Rust code to respectively stdout and\n    // stderr.\n    let stdoutBuffer = \"\";\n    let stderrBuffer = \"\";\n    return {\n        // Need to fill the buffer described by `ptr` and `len` with random data.\n        // This data will be used in order to generate secrets. Do not use a dummy implementation!\n        random_get: (ptr, len) => {\n            const instance = config.instance;\n            ptr >>>= 0;\n            len >>>= 0;\n            const baseBuffer = new Uint8Array(instance.exports.memory.buffer)\n                .slice(ptr, ptr + len);\n            for (let iter = 0; iter < len; iter += 65536) {\n                // `baseBuffer.slice` automatically saturates at the end of the buffer\n                config.getRandomValues(baseBuffer.slice(iter, iter + 65536));\n            }\n            return 0;\n        },\n        // Writing to a file descriptor is used in order to write to stdout/stderr.\n        fd_write: (fd, addr, num, outPtr) => {\n            const instance = config.instance;\n            outPtr >>>= 0;\n            // Only stdout and stderr are open for writing.\n            if (fd != 1 && fd != 2) {\n                return 8;\n            }\n            const mem = new Uint8Array(instance.exports.memory.buffer);\n            // `fd_write` passes a buffer containing itself a list of pointers and lengths to the\n            // actual buffers. See writev(2).\n            let toWrite = \"\";\n            let totalLength = 0;\n            for (let i = 0; i < num; i++) {\n                const buf = buffer.readUInt32LE(mem, addr + 4 * i * 2);\n                const bufLen = buffer.readUInt32LE(mem, addr + 4 * (i * 2 + 1));\n                toWrite += buffer.utf8BytesToString(mem, buf, bufLen);\n                totalLength += bufLen;\n            }\n            const flushBuffer = (string) => {\n                // As documented in the documentation of `println!`, lines are always split by a\n                // single `\\n` in Rust.\n                while (true) {\n                    const index = string.indexOf('\\n');\n                    if (index != -1) {\n                        // Note that it is questionnable to use `console.log` from within a\n                        // library. However this simply reflects the usage of `println!` in the\n                        // Rust code. In other words, it is `println!` that shouldn't be used in\n                        // the first place. The harm of not showing text printed with `println!`\n                        // at all is greater than the harm possibly caused by accidentally leaving\n                        // a `println!` in the code.\n                        console.log(string.substring(0, index));\n                        string = string.substring(index + 1);\n                    }\n                    else {\n                        return string;\n                    }\n                }\n            };\n            // Append the newly-written data to either `stdout_buffer` or `stderr_buffer`, and\n            // print their content if necessary.\n            if (fd == 1) {\n                stdoutBuffer += toWrite;\n                stdoutBuffer = flushBuffer(stdoutBuffer);\n            }\n            else if (fd == 2) {\n                stderrBuffer += toWrite;\n                stderrBuffer = flushBuffer(stderrBuffer);\n            }\n            // Need to write in `out_ptr` how much data was \"written\".\n            buffer.writeUInt32LE(mem, outPtr, totalLength);\n            return 0;\n        },\n        // It's unclear how to properly implement yielding, but a no-op works fine as well.\n        sched_yield: () => {\n            return 0;\n        },\n        // Used by Rust in catastrophic situations, such as a double panic.\n        proc_exit: (retCode) => {\n            config.onProcExit(retCode);\n        },\n        // Return the number of environment variables and the total size of all environment\n        // variables. This is called in order to initialize buffers before `environ_get`.\n        environ_sizes_get: (argcOut, argvBufSizeOut) => {\n            const instance = config.instance;\n            argcOut >>>= 0;\n            argvBufSizeOut >>>= 0;\n            let totalLen = 0;\n            config.envVars.forEach(e => totalLen += new TextEncoder().encode(e).length + 1); // +1 for trailing \\0\n            const mem = new Uint8Array(instance.exports.memory.buffer);\n            buffer.writeUInt32LE(mem, argcOut, config.envVars.length);\n            buffer.writeUInt32LE(mem, argvBufSizeOut, totalLen);\n            return 0;\n        },\n        // Write the environment variables to the given pointers.\n        // `argv` is a pointer to a buffer that must be overwritten with a list of pointers to\n        // environment variables, and `argvBuf` is a pointer to a buffer where to actually store\n        // the environment variables.\n        // The sizes of the buffers were determined by calling `environ_sizes_get`.\n        environ_get: (argv, argvBuf) => {\n            const instance = config.instance;\n            argv >>>= 0;\n            argvBuf >>>= 0;\n            const mem = new Uint8Array(instance.exports.memory.buffer);\n            let argvPos = 0;\n            let argvBufPos = 0;\n            config.envVars.forEach(envVar => {\n                const encoded = new TextEncoder().encode(envVar);\n                buffer.writeUInt32LE(mem, argv + argvPos, argvBuf + argvBufPos);\n                argvPos += 4;\n                mem.set(encoded, argvBuf + argvBufPos);\n                argvBufPos += encoded.length;\n                buffer.writeUInt8(mem, argvBuf + argvBufPos, 0);\n                argvBufPos += 1;\n            });\n            return 0;\n        },\n    };\n};\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport * as buffer from './buffer.js';\nimport { default as tinyInflate } from '../tiny-inflate/index.js';\nimport { default as smoldotLightBindingsBuilder } from './bindings-smoldot-light.js';\nimport { default as wasiBindingsBuilder } from './bindings-wasi.js';\nimport { default as wasmBase64, decompressedSize as wasmDecompressedSize } from './autogen/wasm.js';\nexport { ConnectionError } from './bindings-smoldot-light.js';\nexport async function startInstance(config, platformBindings) {\n    // The actual Wasm bytecode is base64-decoded then deflate-decoded from a constant found in a\n    // different file.\n    // This is suboptimal compared to using `instantiateStreaming`, but it is the most\n    // cross-platform cross-bundler approach.\n    const wasmBytecode = new Uint8Array(wasmDecompressedSize);\n    tinyInflate(buffer.trustedBase64Decode(wasmBase64), wasmBytecode);\n    let killAll;\n    // Used to bind with the smoldot-light bindings. See the `bindings-smoldot-light.js` file.\n    const smoldotJsConfig = {\n        performanceNow: platformBindings.performanceNow,\n        connect: platformBindings.connect,\n        onPanic: (message) => {\n            killAll();\n            config.onWasmPanic(message);\n            throw new Error();\n        },\n        ...config\n    };\n    // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.\n    const wasiConfig = {\n        envVars: [],\n        getRandomValues: platformBindings.getRandomValues,\n        onProcExit: (retCode) => {\n            killAll();\n            config.onWasmPanic(`proc_exit called: ${retCode}`);\n            throw new Error();\n        }\n    };\n    const { imports: smoldotBindings, killAll: smoldotBindingsKillAll } = smoldotLightBindingsBuilder(smoldotJsConfig);\n    killAll = smoldotBindingsKillAll;\n    // Start the Wasm virtual machine.\n    // The Rust code defines a list of imports that must be fulfilled by the environment. The second\n    // parameter provides their implementations.\n    const result = await WebAssembly.instantiate(wasmBytecode, {\n        // The functions with the \"smoldot\" prefix are specific to smoldot.\n        \"smoldot\": smoldotBindings,\n        // As the Rust code is compiled for wasi, some more wasi-specific imports exist.\n        \"wasi_snapshot_preview1\": wasiBindingsBuilder(wasiConfig),\n    });\n    const instance = result.instance;\n    smoldotJsConfig.instance = instance;\n    wasiConfig.instance = instance;\n    return instance;\n}\n","import { default as wasm0 } from './wasm0.js';\nimport { default as wasm1 } from './wasm1.js';\nimport { default as wasm2 } from './wasm2.js';\nexport default \"\" + wasm0() + wasm1() + wasm2();\nexport const decompressedSize = 3997870;\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport { start as startInstance } from './instance/instance.js';\n/**\n * Thrown in case of a problem when initializing the chain.\n */\nexport class AddChainError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"AddChainError\";\n    }\n}\n/**\n * Thrown in case the API user tries to use a chain or client that has already been destroyed.\n */\nexport class AlreadyDestroyedError extends Error {\n    constructor() {\n        super();\n        this.name = \"AlreadyDestroyedError\";\n    }\n}\n/**\n * Thrown when trying to send a JSON-RPC message to a chain whose JSON-RPC system hasn't been\n * enabled.\n */\nexport class JsonRpcDisabledError extends Error {\n    constructor() {\n        super();\n        this.name = \"JsonRpcDisabledError\";\n    }\n}\n/**\n * Thrown in case the underlying client encounters an unexpected crash.\n *\n * This is always an internal bug in smoldot and is never supposed to happen.\n */\nexport class CrashError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n// This function is similar to the `start` function found in `index.ts`, except with an extra\n// parameter containing the platform-specific bindings.\n// Contrary to the one within `index.js`, this function is not supposed to be directly used.\nexport function start(options, platformBindings) {\n    const logCallback = options.logCallback || ((level, target, message) => {\n        // The first parameter of the methods of `console` has some printf-like substitution\n        // capabilities. We don't really need to use this, but not using it means that the logs might\n        // not get printed correctly if they contain `%`.\n        if (level <= 1) {\n            console.error(\"[%s] %s\", target, message);\n        }\n        else if (level == 2) {\n            console.warn(\"[%s] %s\", target, message);\n        }\n        else if (level == 3) {\n            console.info(\"[%s] %s\", target, message);\n        }\n        else if (level == 4) {\n            console.debug(\"[%s] %s\", target, message);\n        }\n        else {\n            console.trace(\"[%s] %s\", target, message);\n        }\n    });\n    // For each chain object returned by `addChain`, the associated internal chain id.\n    //\n    // Immediately cleared when `remove()` is called on a chain.\n    let chainIds = new WeakMap();\n    // If `Client.terminate()̀  is called, this error is set to a value.\n    // All the functions of the public API check if this contains a value.\n    let alreadyDestroyedError = null;\n    const instance = startInstance({\n        // Maximum level of log entries sent by the client.\n        // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace\n        maxLogLevel: options.maxLogLevel || 3,\n        logCallback,\n        // `enableCurrentTask` adds a small performance hit, but adds some additional information to\n        // crash reports. Whether this should be enabled is very opiniated and not that important. At\n        // the moment, we enable it all the time, except if the user has logging disabled altogether.\n        enableCurrentTask: options.maxLogLevel ? options.maxLogLevel >= 1 : true,\n        cpuRateLimit: options.cpuRateLimit || 1.0,\n    }, platformBindings);\n    return {\n        addChain: async (options) => {\n            if (alreadyDestroyedError)\n                throw alreadyDestroyedError;\n            // Passing a JSON object for the chain spec is an easy mistake, so we provide a more\n            // readable error.\n            if (!(typeof options.chainSpec === 'string'))\n                throw new Error(\"Chain specification must be a string\");\n            let potentialRelayChainsIds = [];\n            if (!!options.potentialRelayChains) {\n                for (const chain of options.potentialRelayChains) {\n                    // The content of `options.potentialRelayChains` are supposed to be chains earlier\n                    // returned by `addChain`.\n                    const id = chainIds.get(chain);\n                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.\n                        continue;\n                    potentialRelayChainsIds.push(id);\n                }\n            }\n            const outcome = await instance.addChain(options.chainSpec, typeof options.databaseContent === 'string' ? options.databaseContent : \"\", potentialRelayChainsIds, options.jsonRpcCallback);\n            if (!outcome.success)\n                throw new AddChainError(outcome.error);\n            const chainId = outcome.chainId;\n            const wasDestroyed = { destroyed: false };\n            // `expected` was pushed by the `addChain` method.\n            // Resolve the promise that `addChain` returned to the user.\n            const newChain = {\n                sendJsonRpc: (request) => {\n                    if (alreadyDestroyedError)\n                        throw alreadyDestroyedError;\n                    if (wasDestroyed.destroyed)\n                        throw new AlreadyDestroyedError();\n                    if (!options.jsonRpcCallback)\n                        throw new JsonRpcDisabledError();\n                    if (request.length >= 64 * 1024 * 1024) {\n                        console.error(\"Client.sendJsonRpc ignored a JSON-RPC request because it was too large (\" + request.length + \" bytes)\");\n                        return;\n                    }\n                    ;\n                    instance.request(request, chainId);\n                },\n                databaseContent: (maxUtf8BytesSize) => {\n                    if (alreadyDestroyedError)\n                        return Promise.reject(alreadyDestroyedError);\n                    if (wasDestroyed.destroyed)\n                        throw new AlreadyDestroyedError();\n                    return instance.databaseContent(chainId, maxUtf8BytesSize);\n                },\n                remove: () => {\n                    if (alreadyDestroyedError)\n                        throw alreadyDestroyedError;\n                    if (wasDestroyed.destroyed)\n                        throw new AlreadyDestroyedError();\n                    wasDestroyed.destroyed = true;\n                    console.assert(chainIds.has(newChain));\n                    chainIds.delete(newChain);\n                    instance.removeChain(chainId);\n                },\n            };\n            chainIds.set(newChain, chainId);\n            return newChain;\n        },\n        terminate: async () => {\n            if (alreadyDestroyedError)\n                throw alreadyDestroyedError;\n            alreadyDestroyedError = new AlreadyDestroyedError();\n            instance.startShutdown();\n        }\n    };\n}\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport * as buffer from './buffer.js';\nimport * as instance from './raw-instance.js';\nimport { CrashError } from '../client.js';\nexport { ConnectionError } from './raw-instance.js';\nexport function start(configMessage, platformBindings) {\n    // This variable represents the state of the instance, and serves two different purposes:\n    //\n    // - At initialization, it is a Promise containing the Wasm VM is still initializing.\n    // - After the Wasm VM has finished initialization, contains the `WebAssembly.Instance` object.\n    //\n    let state;\n    const crashError = {};\n    const currentTask = { name: null };\n    const printError = { printError: true };\n    // Contains the information of each chain that is currently alive.\n    let chains = new Map();\n    // Start initialization of the Wasm VM.\n    const config = {\n        onWasmPanic: (message) => {\n            // TODO: consider obtaining a backtrace here\n            crashError.error = new CrashError(message);\n            if (!printError.printError)\n                return;\n            console.error(\"Smoldot has panicked\" +\n                (currentTask.name ? (\" while executing task `\" + currentTask.name + \"`\") : \"\") +\n                \". This is a bug in smoldot. Please open an issue at \" +\n                \"https://github.com/paritytech/smoldot/issues with the following message:\\n\" +\n                message);\n        },\n        logCallback: (level, target, message) => {\n            configMessage.logCallback(level, target, message);\n        },\n        jsonRpcCallback: (data, chainId) => {\n            const cb = chains.get(chainId)?.jsonRpcCallback;\n            if (cb)\n                cb(data);\n        },\n        databaseContentCallback: (data, chainId) => {\n            const promises = chains.get(chainId)?.databasePromises;\n            promises.shift().resolve(data);\n        },\n        currentTaskCallback: (taskName) => {\n            currentTask.name = taskName;\n        },\n        cpuRateLimit: configMessage.cpuRateLimit,\n    };\n    state = {\n        initialized: false, promise: instance.startInstance(config, platformBindings).then((instance) => {\n            // `config.cpuRateLimit` is a floating point that should be between 0 and 1, while the value\n            // to pass as parameter must be between `0` and `2^32-1`.\n            // The few lines of code below should handle all possible values of `number`, including\n            // infinites and NaN.\n            let cpuRateLimit = Math.round(config.cpuRateLimit * 4294967295); // `2^32 - 1`\n            if (cpuRateLimit < 0)\n                cpuRateLimit = 0;\n            if (cpuRateLimit > 4294967295)\n                cpuRateLimit = 4294967295;\n            if (!Number.isFinite(cpuRateLimit))\n                cpuRateLimit = 4294967295; // User might have passed NaN\n            // Smoldot requires an initial call to the `init` function in order to do its internal\n            // configuration.\n            instance.exports.init(configMessage.maxLogLevel, configMessage.enableCurrentTask ? 1 : 0, cpuRateLimit);\n            state = { initialized: true, instance };\n            return instance;\n        })\n    };\n    async function queueOperation(operation) {\n        // What to do depends on the type of `state`.\n        // See the documentation of the `state` variable for information.\n        if (!state.initialized) {\n            // A message has been received while the Wasm VM is still initializing. Queue it for when\n            // initialization is over.\n            return state.promise.then((instance) => operation(instance));\n        }\n        else {\n            // Everything is already initialized. Process the message synchronously.\n            return operation(state.instance);\n        }\n    }\n    return {\n        request: (request, chainId) => {\n            // Because `request` is passed as parameter an identifier returned by `addChain`, it is\n            // always the case that the Wasm instance is already initialized. The only possibility for\n            // it to not be the case is if the user completely invented the `chainId`.\n            if (!state.initialized)\n                throw new Error(\"Internal error\");\n            if (crashError.error)\n                throw crashError.error;\n            try {\n                const encoded = new TextEncoder().encode(request);\n                const ptr = state.instance.exports.alloc(encoded.length) >>> 0;\n                new Uint8Array(state.instance.exports.memory.buffer).set(encoded, ptr);\n                state.instance.exports.json_rpc_send(ptr, encoded.length, chainId);\n            }\n            catch (_error) {\n                console.assert(crashError.error);\n                throw crashError.error;\n            }\n        },\n        addChain: (chainSpec, databaseContent, potentialRelayChains, jsonRpcCallback) => {\n            return queueOperation((instance) => {\n                if (crashError.error)\n                    throw crashError.error;\n                try {\n                    // Write the chain specification into memory.\n                    const chainSpecEncoded = new TextEncoder().encode(chainSpec);\n                    const chainSpecPtr = instance.exports.alloc(chainSpecEncoded.length) >>> 0;\n                    new Uint8Array(instance.exports.memory.buffer).set(chainSpecEncoded, chainSpecPtr);\n                    // Write the database content into memory.\n                    const databaseContentEncoded = new TextEncoder().encode(databaseContent);\n                    const databaseContentPtr = instance.exports.alloc(databaseContentEncoded.length) >>> 0;\n                    new Uint8Array(instance.exports.memory.buffer).set(databaseContentEncoded, databaseContentPtr);\n                    // Write the potential relay chains into memory.\n                    const potentialRelayChainsLen = potentialRelayChains.length;\n                    const potentialRelayChainsPtr = instance.exports.alloc(potentialRelayChainsLen * 4) >>> 0;\n                    for (let idx = 0; idx < potentialRelayChains.length; ++idx) {\n                        buffer.writeUInt32LE(new Uint8Array(instance.exports.memory.buffer), potentialRelayChainsPtr + idx * 4, potentialRelayChains[idx]);\n                    }\n                    // `add_chain` unconditionally allocates a chain id. If an error occurs, however, this chain\n                    // id will refer to an *erroneous* chain. `chain_is_ok` is used below to determine whether it\n                    // has succeeeded or not.\n                    // Note that `add_chain` properly de-allocates buffers even if it failed.\n                    const chainId = instance.exports.add_chain(chainSpecPtr, chainSpecEncoded.length, databaseContentPtr, databaseContentEncoded.length, !!jsonRpcCallback ? 1 : 0, potentialRelayChainsPtr, potentialRelayChainsLen);\n                    if (instance.exports.chain_is_ok(chainId) != 0) {\n                        console.assert(!chains.has(chainId));\n                        chains.set(chainId, {\n                            jsonRpcCallback,\n                            databasePromises: new Array()\n                        });\n                        return { success: true, chainId };\n                    }\n                    else {\n                        const errorMsgLen = instance.exports.chain_error_len(chainId) >>> 0;\n                        const errorMsgPtr = instance.exports.chain_error_ptr(chainId) >>> 0;\n                        const errorMsg = buffer.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), errorMsgPtr, errorMsgLen);\n                        instance.exports.remove_chain(chainId);\n                        return { success: false, error: errorMsg };\n                    }\n                }\n                catch (_error) {\n                    console.assert(crashError.error);\n                    throw crashError.error;\n                }\n            });\n        },\n        removeChain: (chainId) => {\n            // Because `removeChain` is passed as parameter an identifier returned by `addChain`, it is\n            // always the case that the Wasm instance is already initialized. The only possibility for\n            // it to not be the case is if the user completely invented the `chainId`.\n            if (!state.initialized)\n                throw new Error(\"Internal error\");\n            if (crashError.error)\n                throw crashError.error;\n            // Removing the chain synchronously avoids having to deal with race conditions such as a\n            // JSON-RPC response corresponding to a chain that is going to be deleted but hasn't been yet.\n            // These kind of race conditions are already delt with within smoldot.\n            console.assert(chains.has(chainId));\n            chains.delete(chainId);\n            try {\n                state.instance.exports.remove_chain(chainId);\n            }\n            catch (_error) {\n                console.assert(crashError.error);\n                throw crashError.error;\n            }\n        },\n        databaseContent: (chainId, maxUtf8BytesSize) => {\n            // Because `databaseContent` is passed as parameter an identifier returned by `addChain`, it\n            // is always the case that the Wasm instance is already initialized. The only possibility for\n            // it to not be the case is if the user completely invented the `chainId`.\n            if (!state.initialized)\n                throw new Error(\"Internal error\");\n            if (crashError.error)\n                throw crashError.error;\n            console.assert(chains.has(chainId));\n            const databaseContentPromises = chains.get(chainId)?.databasePromises;\n            const promise = new Promise((resolve, reject) => {\n                databaseContentPromises.push({ resolve, reject });\n            });\n            // Cap `maxUtf8BytesSize` and set a default value.\n            const twoPower32 = (1 << 30) * 4; // `1 << 31` and `1 << 32` in JavaScript don't give the value that you expect.\n            const maxSize = maxUtf8BytesSize || (twoPower32 - 1);\n            const cappedMaxSize = (maxSize >= twoPower32) ? (twoPower32 - 1) : maxSize;\n            // The value of `maxUtf8BytesSize` is guaranteed to always fit in 32 bits, in\n            // other words, that `maxUtf8BytesSize < (1 << 32)`.\n            // We need to perform a conversion in such a way that the the bits of the output of\n            // `ToInt32(converted)`, when interpreted as u32, is equal to `maxUtf8BytesSize`.\n            // See ToInt32 here: https://tc39.es/ecma262/#sec-toint32\n            // Note that the code below has been tested against example values. Please be very careful\n            // if you decide to touch it. Ideally it would be unit-tested, but since it concerns the FFI\n            // layer between JS and Rust, writing unit tests would be extremely complicated.\n            const twoPower31 = (1 << 30) * 2; // `1 << 31` in JavaScript doesn't give the value that you expect.\n            const converted = (cappedMaxSize >= twoPower31) ?\n                (cappedMaxSize - twoPower32) : cappedMaxSize;\n            try {\n                state.instance.exports.database_content(chainId, converted);\n                return promise;\n            }\n            catch (_error) {\n                console.assert(crashError.error);\n                throw crashError.error;\n            }\n        },\n        startShutdown: () => {\n            return queueOperation((instance) => {\n                // `startShutdown` is a bit special in its handling of crashes.\n                // Shutting down will lead to `onWasmPanic` being called at some point, possibly during\n                // the call to `start_shutdown` itself. As such, we move into \"don't print errors anymore\"\n                // mode even before calling `start_shutdown`.\n                //\n                // Furthermore, if a crash happened in the past, there is no point in throwing an\n                // exception when the user wants the shutdown to happen.\n                if (crashError.error)\n                    return;\n                try {\n                    printError.printError = false;\n                    instance.exports.start_shutdown();\n                }\n                catch (_error) {\n                }\n            });\n        }\n    };\n}\n","// Smoldot\n// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n/// <reference lib=\"dom\" />\nimport { start as innerStart } from './client.js';\nimport { ConnectionError } from './instance/instance.js';\nexport { AddChainError, AlreadyDestroyedError, CrashError, JsonRpcDisabledError } from './client.js';\n/**\n * Initializes a new client. This is a pre-requisite to connecting to a blockchain.\n *\n * Can never fail.\n *\n * @param options Configuration of the client. Defaults to `{}`.\n */\nexport function start(options) {\n    options = options || {};\n    return innerStart(options, {\n        performanceNow: () => {\n            return performance.now();\n        },\n        getRandomValues: (buffer) => {\n            const crypto = globalThis.crypto;\n            if (!crypto)\n                throw new Error('randomness not available');\n            crypto.getRandomValues(buffer);\n        },\n        connect: (config) => {\n            return connect(config, options?.forbidWs || false, options?.forbidNonLocalWs || false, options?.forbidWss || false);\n        }\n    });\n}\n/**\n * Tries to open a new connection using the given configuration.\n *\n * @see Connection\n * @throws ConnectionError If the multiaddress couldn't be parsed or contains an invalid protocol.\n */\nfunction connect(config, forbidWs, forbidNonLocalWs, forbidWss) {\n    let connection;\n    // Attempt to parse the multiaddress.\n    // TODO: remove support for `/wss` in a long time (https://github.com/paritytech/smoldot/issues/1940)\n    const wsParsed = config.address.match(/^\\/(ip4|ip6|dns4|dns6|dns)\\/(.*?)\\/tcp\\/(.*?)\\/(ws|wss|tls\\/ws)$/);\n    if (wsParsed != null) {\n        const proto = (wsParsed[4] == 'ws') ? 'ws' : 'wss';\n        if ((proto == 'ws' && forbidWs) ||\n            (proto == 'ws' && wsParsed[2] != 'localhost' && wsParsed[2] != '127.0.0.1' && forbidNonLocalWs) ||\n            (proto == 'wss' && forbidWss)) {\n            throw new ConnectionError('Connection type not allowed');\n        }\n        const url = (wsParsed[1] == 'ip6') ?\n            (proto + \"://[\" + wsParsed[2] + \"]:\" + wsParsed[3]) :\n            (proto + \"://\" + wsParsed[2] + \":\" + wsParsed[3]);\n        connection = new WebSocket(url);\n        connection.binaryType = 'arraybuffer';\n        connection.onopen = () => {\n            config.onOpen();\n        };\n        connection.onclose = (event) => {\n            const message = \"Error code \" + event.code + (!!event.reason ? (\": \" + event.reason) : \"\");\n            config.onClose(message);\n        };\n        connection.onmessage = (msg) => {\n            config.onMessage(new Uint8Array(msg.data));\n        };\n    }\n    else {\n        throw new ConnectionError('Unrecognized multiaddr format');\n    }\n    return {\n        close: () => {\n            connection.onopen = null;\n            connection.onclose = null;\n            connection.onmessage = null;\n            connection.onerror = null;\n            connection.close();\n        },\n        send: (data) => {\n            connection.send(data);\n        }\n    };\n}\n"],"names":["utf8BytesToString","buffer","offset","length","checkRange","TextDecoder","decode","slice","readUInt32LE","writeUInt8","value","writeUInt32LE","Number","isInteger","RangeError","Tree","this","table","Uint16Array","trans","Data","source","dest","sourceIndex","tag","bitcount","destLen","ltree","dtree","sltree","sdtree","length_bits","Uint8Array","length_base","dist_bits","dist_base","clcidx","code_tree","lengths","tinf_build_bits_base","bits","base","delta","first","i","sum","offs","tinf_build_tree","t","off","num","tinf_getbit","d","bit","tinf_read_bits","val","tinf_decode_symbol","cur","len","tinf_decode_trees","lt","dt","hlit","hdist","hclen","clen","sym","prev","tinf_inflate_block_data","dist","tinf_inflate_uncompressed_block","tinf_build_fixed_trees","bfinal","res","Error","subarray","ConnectionError","constructor","message","super","config","stdoutBuffer","stderrBuffer","random_get","ptr","instance","baseBuffer","exports","memory","iter","getRandomValues","fd_write","fd","addr","outPtr","mem","toWrite","totalLength","buf","bufLen","flushBuffer","string","index","indexOf","console","log","substring","sched_yield","proc_exit","retCode","onProcExit","environ_sizes_get","argcOut","argvBufSizeOut","totalLen","envVars","forEach","e","TextEncoder","encode","environ_get","argv","argvBuf","argvPos","argvBufPos","envVar","encoded","set","async","startInstance","platformBindings","wasmBytecode","killAll","tinyInflate","base64","nInLen","nOutLen","taBytes","nMod3","nMod4","nUint24","nOutIdx","nInIdx","nChr","charCodeAt","smoldotJsConfig","performanceNow","connect","onPanic","onWasmPanic","wasiConfig","imports","smoldotBindings","smoldotBindingsKillAll","connections","killedTracked","killed","panic","json_rpc_respond","chainId","jsonRpcCallback","database_content_ready","content","databaseContentCallback","level","targetPtr","targetLen","messagePtr","messageLen","logCallback","target","unix_time_ms","Date","now","monotonic_clock_ms","start_timer","id","ms","setImmediate","timer_finished","_error","setTimeout","connection_new","connectionId","addrPtr","addrLen","errorPtrPtr","address","connec","onOpen","connection_open_single_stream","onClose","alloc","connection_closed","onMessage","stream_message","error","isBadAddress","errorStr","toString","connection_close","close","connection_stream_open","_connectionId","connection_stream_close","_streamId","stream_send","data","send","current_task_entered","taskName","currentTaskCallback","current_task_exit","connection","smoldotLightBindingsBuilder","WebAssembly","instantiate","wasiBindingsBuilder","AddChainError","name","AlreadyDestroyedError","JsonRpcDisabledError","CrashError","start","options","warn","info","debug","trace","chainIds","WeakMap","alreadyDestroyedError","configMessage","state","crashError","currentTask","printError","chains","Map","cb","get","databasePromises","shift","resolve","cpuRateLimit","queueOperation","operation","initialized","promise","then","Math","round","isFinite","init","maxLogLevel","enableCurrentTask","request","json_rpc_send","assert","addChain","chainSpec","databaseContent","potentialRelayChains","chainSpecEncoded","chainSpecPtr","databaseContentEncoded","databaseContentPtr","potentialRelayChainsLen","potentialRelayChainsPtr","idx","add_chain","chain_is_ok","has","Array","success","errorMsgLen","chain_error_len","errorMsgPtr","chain_error_ptr","errorMsg","remove_chain","removeChain","delete","maxUtf8BytesSize","databaseContentPromises","Promise","reject","push","twoPower32","maxSize","cappedMaxSize","converted","database_content","startShutdown","start_shutdown","potentialRelayChainsIds","chain","undefined","outcome","wasDestroyed","destroyed","newChain","sendJsonRpc","remove","terminate","innerStart","performance","crypto","globalThis","forbidWs","forbidNonLocalWs","forbidWss","wsParsed","match","proto","url","WebSocket","binaryType","onopen","onclose","event","code","reason","onmessage","msg","onerror"],"sourceRoot":""}